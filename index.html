<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - exporter - stl</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #000;
				color: #fff;
				margin: 0px;
				overflow: hidden;
			}
			#info {
				color: #fff;
				position: absolute;
				top: 10px;
				width: 100%;
				text-align: center;
				display:block;
			}
			#info a {
				color: #046;
				font-weight: bold;
			}
		</style>
	</head>
	<body>
		<!-- <div id="info">
			<a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> webgl - exporter - stl
		</div> -->

    <script src="js/three.js"></script>
		<!-- <script src="js/controls/OrbitControls.js"></script> -->
		<script src="js/exporters/STLExporter.js"></script>
    <script src="js/controls/TrackballControls.js"></script>

		<script src="js/Detector.js"></script>
		<script src="js/libs/dat.gui.min.js"></script>
    <script src="js/libs/stats.min.js"></script>

		<script>

			if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

			var camera, controls, scene, renderer, stats;

			function trim (str) {
          str = str.replace(/^\s+/, '');
          for (var i = str.length - 1; i >= 0; i--) {
              if (/\S/.test(str.charAt(i))) {
                  str = str.substring(0, i + 1);
                  break;
              }
          }
          return str;
      }

      // Notes:
      // - STL file format: http://en.wikipedia.org/wiki/STL_(file_format)
      // - 80 byte unused header
      // - All binary STLs are assumed to be little endian, as per wiki doc
      var parseStlBinary = function(stl) {
          var geo = new THREE.Geometry();
          var dv = new DataView(stl, 80); // 80 == unused header
          var isLittleEndian = true;
          var triangles = dv.getUint32(0, isLittleEndian);

          // console.log('arraybuffer length:  ' + stl.byteLength);
          // console.log('number of triangles: ' + triangles);

          var offset = 4;
          for (var i = 0; i < triangles; i++) {
              // Get the normal for this triangle
              var normal = new THREE.Vector3(
                  dv.getFloat32(offset, isLittleEndian),
                  dv.getFloat32(offset+4, isLittleEndian),
                  dv.getFloat32(offset+8, isLittleEndian)
              );
              offset += 12;

              // Get all 3 vertices for this triangle
              for (var j = 0; j < 3; j++) {
                  geo.vertices.push(
                      new THREE.Vector3(
                          dv.getFloat32(offset, isLittleEndian),
                          dv.getFloat32(offset+4, isLittleEndian),
                          dv.getFloat32(offset+8, isLittleEndian)
                      )
                  );
                  offset += 12
              }

              // there's also a Uint16 "attribute byte count" that we
              // don't need, it should always be zero.
              offset += 2;

              // Create a new face for from the vertices and the normal
              geo.faces.push(new THREE.Face3(i*3, i*3+1, i*3+2, normal));
          }

          // The binary STL I'm testing with seems to have all
          // zeroes for the normals, unlike its ASCII counterpart.
          // We can use three.js to compute the normals for us, though,
          // once we've assembled our geometry. This is a relatively
          // expensive operation, but only needs to be done once.
          geo.computeFaceNormals();

          mesh = new THREE.Mesh(
              geo,
              // new THREE.MeshNormalMaterial({
              //     overdraw:true
              // }
              new THREE.MeshLambertMaterial({
                  overdraw:true,
                  color: 0xaaaa00,
                  shading: THREE.FlatShading
              }
          ));
          scene.add(mesh);

          stl = null;
      };

      var parseStl = function(stl) {
          var state = '';
          var lines = stl.split('\n');
          var geo = new THREE.Geometry();
          var name, parts, line, normal, done, vertices = [];
          var vCount = 0;
          stl = null;

          for (var len = lines.length, i = 0; i < len; i++) {
              if (done) {
                  break;
              }
              line = trim(lines[i]);
              parts = line.split(' ');
              switch (state) {
                  case '':
                      if (parts[0] !== 'solid') {
                          console.error(line);
                          console.error('Invalid state "' + parts[0] + '", should be "solid"');
                          return;
                      } else {
                          name = parts[1];
                          state = 'solid';
                      }
                      break;
                  case 'solid':
                      if (parts[0] !== 'facet' || parts[1] !== 'normal') {
                          console.error(line);
                          console.error('Invalid state "' + parts[0] + '", should be "facet normal"');
                          return;
                      } else {
                          normal = [
                              parseFloat(parts[2]),
                              parseFloat(parts[3]),
                              parseFloat(parts[4])
                          ];
                          state = 'facet normal';
                      }
                      break;
                  case 'facet normal':
                      if (parts[0] !== 'outer' || parts[1] !== 'loop') {
                          console.error(line);
                          console.error('Invalid state "' + parts[0] + '", should be "outer loop"');
                          return;
                      } else {
                          state = 'vertex';
                      }
                      break;
                  case 'vertex':
                      if (parts[0] === 'vertex') {
                          geo.vertices.push(new THREE.Vector3(
                              parseFloat(parts[1]),
                              parseFloat(parts[2]),
                              parseFloat(parts[3])
                          ));
                      } else if (parts[0] === 'endloop') {
                          geo.faces.push( new THREE.Face3( vCount*3, vCount*3+1, vCount*3+2, new THREE.Vector3(normal[0], normal[1], normal[2]) ) );
                          vCount++;
                          state = 'endloop';
                      } else {
                          console.error(line);
                          console.error('Invalid state "' + parts[0] + '", should be "vertex" or "endloop"');
                          return;
                      }
                      break;
                  case 'endloop':
                      if (parts[0] !== 'endfacet') {
                          console.error(line);
                          console.error('Invalid state "' + parts[0] + '", should be "endfacet"');
                          return;
                      } else {
                          state = 'endfacet';
                      }
                      break;
                  case 'endfacet':
                      if (parts[0] === 'endsolid') {
                          //mesh = new THREE.Mesh( geo, new THREE.MeshNormalMaterial({overdraw:true}));
                          mesh = new THREE.Mesh(
                              geo,
                              new THREE.MeshLambertMaterial({
                                  overdraw:true,
                                  color: 0xaaaa00,
                                  shading: THREE.FlatShading
                              }
                          ));
                          scene.add(mesh);
                          done = true;
                      } else if (parts[0] === 'facet' && parts[1] === 'normal') {
                          normal = [
                              parseFloat(parts[2]),
                              parseFloat(parts[3]),
                              parseFloat(parts[4])
                          ];
                          if (vCount % 1000 === 0) {
                              console.log(normal);
                          }
                          state = 'facet normal';
                      } else {
                          console.error(line);
                          console.error('Invalid state "' + parts[0] + '", should be "endsolid" or "facet normal"');
                          return;
                      }
                      break;
                  default:
                      console.error('Invalid state "' + state + '"');
                      break;
              }
          }
      };

      init();
			animate();

      function init() {

				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.z = 100;

        controls = new THREE.TrackballControls( camera );

				controls.rotateSpeed = 3.0;
				controls.zoomSpeed = 2.0;
				controls.panSpeed = 0.8;

				controls.noZoom = false;
				controls.noPan = false;

				controls.staticMoving = true;
				controls.dynamicDampingFactor = 0.3;

				controls.keys = [ 65, 83, 68 ];

				controls.addEventListener( 'change', render );

				// world

        scene = new THREE.Scene();
				scene.background = new THREE.Color( 0xcccccc );
				scene.fog = new THREE.FogExp2( 0xcccccc, 0.002 );

				// var geometry = new THREE.CylinderBufferGeometry( 0, 10, 30, 4, 1 );
				// var material = new THREE.MeshPhongMaterial( { color: 0xffffff, flatShading: true } );
        //
				// for ( var i = 0; i < 500; i ++ ) {
        //
				// 	var mesh = new THREE.Mesh( geometry, material );
				// 	mesh.position.x = ( Math.random() - 0.5 ) * 1000;
				// 	mesh.position.y = ( Math.random() - 0.5 ) * 1000;
				// 	mesh.position.z = ( Math.random() - 0.5 ) * 1000;
				// 	mesh.updateMatrix();
				// 	mesh.matrixAutoUpdate = false;
				// 	// scene.add( mesh );
        //
				// }

        var xhr = new XMLHttpRequest();
        xhr.onreadystatechange = function () {
            if ( xhr.readyState == 4 ) {
                if ( xhr.status == 200 || xhr.status == 0 ) {
                    var rep = xhr.response; // || xhr.mozResponseArrayBuffer;
                    console.log(rep);
                    parseStlBinary(rep);
                    //parseStl(xhr.responseText);
                    mesh.rotation.x = 5;
                    mesh.rotation.z = .25;
                    console.log('done parsing');
                }
            }
        }
        xhr.onerror = function(e) {
            console.log(e);
        }

        xhr.open( "GET", 'stone.stl', true );
        xhr.responseType = "arraybuffer";
        //xhr.setRequestHeader("Accept","text/plain");
        //xhr.setRequestHeader("Content-Type","text/plain");
        //xhr.setRequestHeader('charset', 'x-user-defined');
        xhr.send( null );

				// lights

				var light = new THREE.DirectionalLight( 0xffffff );
				light.position.set( 1, 1, 1 );
				scene.add( light );

				var light = new THREE.DirectionalLight( 0x002288 );
				light.position.set( -1, -1, -1 );
				scene.add( light );

				var light = new THREE.AmbientLight( 0x222222 );
				scene.add( light );

				// renderer

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );

				stats = new Stats();
				document.body.appendChild( stats.dom );

				//

				window.addEventListener( 'resize', onWindowResize, false );
				//

				render();

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize( window.innerWidth, window.innerHeight );
				controls.handleResize();

				render();

			}

			function animate() {

				requestAnimationFrame( animate );
				controls.update();

			}

			function render() {

				renderer.render( scene, camera );
				stats.update();

			}

		</script>

	</body>
</html>
